name: Mirror to Production Repo

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'ç‰ˆæœ¬éžå¢žé¡žåž‹ï¼ˆç”¨æ–¼ Release Notesï¼‰'
        required: false
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

      pr_title:
        description: 'Pull Request æ¨™é¡Œï¼ˆé¸å¡«ï¼Œé è¨­æœƒè‡ªå‹•ç”Ÿæˆï¼‰'
        required: false
        type: string

# SECURITY: Limit GITHUB_TOKEN permissions to minimum required
permissions:
  contents: write  # Need write for creating/updating production branch

jobs:
  sync-to-production:
    name: Sync to Production Repository
    runs-on: ubuntu-latest
    # Only run if secrets are configured
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for proper merging
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check for required secrets
        id: check-secrets
        run: |
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            echo "::error::GH_PAT secret not configured"
            echo "::error::Please configure GH_PAT with write access to production repo"
            exit 1
          fi

          if [ -z "${{ secrets.PRODUCTION_REPO }}" ]; then
            echo "::error::PRODUCTION_REPO secret not configured"
            echo "::error::Please set PRODUCTION_REPO to format: owner/repo-name"
            exit 1
          fi

          echo "configured=true" >> $GITHUB_OUTPUT

      - name: Initialize or switch to production branch
        run: |
          echo "::group::Initialize production branch"

          # Fetch all branches
          git fetch origin

          # Check if production branch exists locally or remotely
          if git show-ref --verify --quiet refs/heads/production; then
            echo "::notice::Production branch exists locally, checking out"
            git checkout production
          elif git show-ref --verify --quiet refs/remotes/origin/production; then
            echo "::notice::Production branch exists remotely, checking out"
            git checkout -b production origin/production
          else
            echo "::notice::Creating new production branch from main"
            git checkout -b production
          fi

          echo "::endgroup::"

      - name: Sync from production repository
        env:
          PRODUCTION_REPO: ${{ secrets.PRODUCTION_REPO }}
          PRODUCTION_BRANCH: ${{ secrets.PRODUCTION_BRANCH || 'main' }}
        run: |
          echo "::group::Syncing from production repository"

          # Add production repo as remote
          echo "::notice::Adding production repository as remote"
          git remote add prod-repo "https://x-access-token:${{ secrets.GH_PAT }}@github.com/${PRODUCTION_REPO}.git" 2>/dev/null || true

          # Fetch production repository
          echo "::notice::Fetching production repository: ${PRODUCTION_REPO}:${PRODUCTION_BRANCH}"
          if git fetch prod-repo "${PRODUCTION_BRANCH}" 2>/dev/null; then
            echo "::notice::Production repository fetched successfully"

            # Get current HEAD commit before merge
            BEFORE_MERGE=$(git rev-parse HEAD)

            # Merge production changes (prioritize production repo changes)
            echo "::notice::Merging production changes (using -X theirs strategy)"
            if git merge prod-repo/"${PRODUCTION_BRANCH}" -X theirs \
              --allow-unrelated-histories \
              -m "chore: sync from production repository

            Synced from ${PRODUCTION_REPO}:${PRODUCTION_BRANCH}
            Strategy: theirs (prioritize production changes)
            Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            " 2>&1 | tee /tmp/merge-output.txt; then

              # Check if there were actual changes
              AFTER_MERGE=$(git rev-parse HEAD)
              if [ "$BEFORE_MERGE" != "$AFTER_MERGE" ]; then
                echo "::notice::âœ… Synced changes from production repository"

                # Show what was synced
                echo "::notice::Changes synced:"
                git log --oneline "${BEFORE_MERGE}..${AFTER_MERGE}" | head -10 || true

                # Save for release notes
                echo "PROD_SYNC_COMMITS<<EOF" >> $GITHUB_ENV
                git log --format="- %s (%an, %ar)" "${BEFORE_MERGE}..prod-repo/${PRODUCTION_BRANCH}" | head -20 || echo "No new commits"
                echo "EOF" >> $GITHUB_ENV
              else
                echo "::notice::No changes to sync from production repository"
                echo "PROD_SYNC_COMMITS=No changes from production repository" >> $GITHUB_ENV
              fi
            else
              echo "::warning::Merge encountered conflicts, resolving with theirs strategy"
              # Accept all their changes
              git checkout --theirs .
              git add -A
              git commit -m "chore: sync from production repository (auto-resolved conflicts)

              Synced from ${PRODUCTION_REPO}:${PRODUCTION_BRANCH}
              Conflicts auto-resolved using theirs strategy
              Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
              " || echo "::notice::No conflicts to resolve"

              echo "PROD_SYNC_COMMITS=Synced with conflict resolution (theirs strategy)" >> $GITHUB_ENV
            fi
          else
            echo "::notice::Production repository not found or first sync"
            echo "::notice::This is expected for first-time setup"
            echo "PROD_SYNC_COMMITS=First sync - no previous production repository" >> $GITHUB_ENV
          fi

          echo "::endgroup::"

      - name: Merge latest from main branch
        run: |
          echo "::group::Merging latest from main"

          # Get current HEAD before merge
          BEFORE_MERGE=$(git rev-parse HEAD)

          # Fetch and merge main
          git fetch origin main
          echo "::notice::Merging latest changes from main branch"

          if git merge origin/main -m "chore: merge latest from main

          Merged latest development changes from main branch
          Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          "; then
            # Check if there were actual changes
            AFTER_MERGE=$(git rev-parse HEAD)
            if [ "$BEFORE_MERGE" != "$AFTER_MERGE" ]; then
              echo "::notice::âœ… Merged changes from main"

              # Show what was merged
              echo "::notice::Changes from main:"
              git log --oneline "${BEFORE_MERGE}..${AFTER_MERGE}" | head -10 || true

              # Save for release notes
              echo "MAIN_MERGE_COMMITS<<EOF" >> $GITHUB_ENV
              git log --format="- %s (%an, %ar)" "${BEFORE_MERGE}..origin/main" | head -20
              echo "EOF" >> $GITHUB_ENV
            else
              echo "::notice::No new changes from main branch"
              echo "MAIN_MERGE_COMMITS=No new changes from main" >> $GITHUB_ENV
            fi
          else
            echo "::error::Failed to merge from main - manual intervention required"
            exit 1
          fi

          echo "::endgroup::"

      - name: Remove development workflows
        run: |
          echo "::group::Removing development workflows"

          # Remove .github/workflows directory
          if [ -d ".github/workflows" ]; then
            echo "::notice::Removing .github/workflows/ directory"

            # List files being removed
            echo "::notice::Files to be removed:"
            find .github/workflows -type f -name "*.yml" -o -name "*.yaml" | tee /tmp/removed-workflows.txt

            git rm -rf .github/workflows/

            # Count removed files
            REMOVED_COUNT=$(wc -l < /tmp/removed-workflows.txt || echo "0")
            echo "::notice::Removed $REMOVED_COUNT workflow file(s)"
            echo "REMOVED_WORKFLOWS_COUNT=$REMOVED_COUNT" >> $GITHUB_ENV

            # Save list for release notes
            echo "REMOVED_WORKFLOWS<<EOF" >> $GITHUB_ENV
            cat /tmp/removed-workflows.txt || echo "None"
            echo "EOF" >> $GITHUB_ENV
          else
            echo "::notice::No .github/workflows/ directory found"
            echo "REMOVED_WORKFLOWS_COUNT=0" >> $GITHUB_ENV
            echo "REMOVED_WORKFLOWS=No workflows to remove" >> $GITHUB_ENV
          fi

          # If .github directory is now empty, remove it
          if [ -d ".github" ] && [ -z "$(ls -A .github 2>/dev/null)" ]; then
            echo "::notice::Removing empty .github/ directory"
            git rm -rf .github/
          fi

          # Commit the removal
          if git diff --cached --quiet; then
            echo "::notice::No workflows to remove"
          else
            git commit -m "chore: remove development workflows for production

            Development workflows are not needed in production repository.
            Production repo will maintain its own deployment and monitoring workflows.

            Removed workflows: ${REMOVED_WORKFLOWS_COUNT} files
            Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            "
            echo "::notice::âœ… Committed workflow removal"
          fi

          echo "::endgroup::"

      - name: Remove development-only directories
        run: |
          echo "::group::Removing development-only directories"

          REMOVED_DIRS=""

          # Remove mock-student-api (development only)
          if [ -d "mock-student-api" ]; then
            echo "::notice::Removing mock-student-api/ directory"
            git rm -rf mock-student-api/
            REMOVED_DIRS="${REMOVED_DIRS}- mock-student-api/ (Mock Student API)\n"
          fi

          # Remove .claude directory (Claude Code project configuration)
          if [ -d ".claude" ]; then
            echo "::notice::Removing .claude/ directory"
            git rm -rf .claude/
            REMOVED_DIRS="${REMOVED_DIRS}- .claude/ (Claude Code configuration)\n"
          fi

          # Save for release notes
          if [ -n "$REMOVED_DIRS" ]; then
            echo "REMOVED_DIRS<<EOF" >> $GITHUB_ENV
            echo -e "$REMOVED_DIRS" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "REMOVED_DIRS=No development directories to remove" >> $GITHUB_ENV
          fi

          # Commit the removal
          if git diff --cached --quiet; then
            echo "::notice::No development directories to remove"
          else
            git commit -m "chore: remove development-only directories for production

            Development directories are not needed in production:
            $(echo -e "$REMOVED_DIRS")

            Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            "
            echo "::notice::âœ… Committed development directories removal"
          fi

          echo "::endgroup::"

      - name: Preserve production workflows
        id: preserve-workflows
        continue-on-error: true
        env:
          PRODUCTION_REPO: ${{ secrets.PRODUCTION_REPO }}
          PRODUCTION_BRANCH: ${{ secrets.PRODUCTION_BRANCH || 'main' }}
        run: |
          echo "::group::Preserving production workflows"

          # Try to fetch production workflows
          echo "::notice::Fetching production workflows..."
          if git ls-tree -r prod-repo/${PRODUCTION_BRANCH} --name-only 2>/dev/null | grep -q "^.github/workflows/"; then
            echo "::notice::Production has workflows, preserving them..."

            # Create temp directory
            mkdir -p /tmp/production-workflows

            # Extract production workflows to temp
            git archive prod-repo/${PRODUCTION_BRANCH} .github/workflows | tar -x -C /tmp/production-workflows 2>/dev/null || true

            # Copy production workflows back
            if [ -d "/tmp/production-workflows/.github/workflows" ]; then
              mkdir -p .github/workflows
              cp -r /tmp/production-workflows/.github/workflows/* .github/workflows/ 2>/dev/null || true

              WORKFLOW_COUNT=$(find .github/workflows -type f \( -name "*.yml" -o -name "*.yaml" \) 2>/dev/null | wc -l)
              echo "::notice::âœ… Preserved $WORKFLOW_COUNT production workflow(s)"

              # List preserved workflows
              echo "::notice::Preserved workflows:"
              find .github/workflows -type f \( -name "*.yml" -o -name "*.yaml" \) -exec basename {} \; || true

              # Add to git
              git add .github/workflows/

              # Commit preservation
              if ! git diff --cached --quiet; then
                git commit -m "chore: preserve production workflows

                Preserved ${WORKFLOW_COUNT} workflow(s) from production repository
                Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
                "
                echo "::notice::âœ… Production workflows preserved and committed"
              fi

              echo "preserved_count=$WORKFLOW_COUNT" >> $GITHUB_OUTPUT
            else
              echo "::notice::No production workflows found to preserve"
              echo "preserved_count=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "::notice::Production repo has no .github/workflows/ directory"
            echo "preserved_count=0" >> $GITHUB_OUTPUT
          fi

          # Cleanup temp directory
          rm -rf /tmp/production-workflows

          echo "::endgroup::"

      - name: Calculate next version
        id: version
        env:
          VERSION_BUMP: ${{ github.event.inputs.version_bump || 'patch' }}
        run: |
          echo "::group::Calculate next version"

          # Fetch tags from production repo
          git fetch prod-repo --tags 2>/dev/null || true

          # Get latest semantic version tag
          LATEST_TAG=$(git tag -l "v*.*.*" --sort=-v:refname | head -1 || echo "")

          if [ -z "$LATEST_TAG" ]; then
            echo "::notice::No previous version found, starting with v1.0.0"
            NEXT_VERSION="v1.0.0"
          else
            echo "::notice::Latest version: $LATEST_TAG"

            # Parse version (remove 'v' prefix)
            VERSION=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

            # Increment based on bump type
            case "$VERSION_BUMP" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "::notice::Next version: $NEXT_VERSION"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "NEXT_VERSION=$NEXT_VERSION" >> $GITHUB_ENV

          echo "::endgroup::"

      - name: Generate release notes
        id: release-notes
        run: |
          echo "::group::Generate release notes"

          # Create release notes file
          cat > /tmp/release-notes.md <<'RELEASE_NOTES_EOF'
          # ðŸš€ Production Sync ${{ env.NEXT_VERSION }}

          ## ðŸ“‹ Summary

          This release syncs the latest changes from the development repository to production.

          | Property | Value |
          |----------|-------|
          | **Version** | ${{ env.NEXT_VERSION }} |
          | **Source Repo** | [${{ github.repository }}](https://github.com/${{ github.repository }}) |
          | **Source Commit** | [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }}) |
          | **Sync Date** | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |
          | **Triggered By** | @${{ github.actor }} |

          ## ðŸ”„ Changes Synced from Production Repository

          ${{ env.PROD_SYNC_COMMITS }}

          ## âœ¨ Changes Merged from Main Branch

          ${{ env.MAIN_MERGE_COMMITS }}

          ## ðŸ“Š File Changes

          RELEASE_NOTES_EOF

          # Add file statistics
          echo "" >> /tmp/release-notes.md
          echo "\`\`\`" >> /tmp/release-notes.md
          git diff --stat origin/main..HEAD | tail -1 >> /tmp/release-notes.md || echo "No file changes" >> /tmp/release-notes.md
          echo "\`\`\`" >> /tmp/release-notes.md

          # Add removed development files
          cat >> /tmp/release-notes.md <<'REMOVED_FILES_EOF'

          ## ðŸš« Removed Development Files

          ### Workflows Removed
          ${{ env.REMOVED_WORKFLOWS }}

          ### Directories Removed
          ${{ env.REMOVED_DIRS }}

          ## ðŸ“ Notes

          - This is a production-ready snapshot with development files removed
          - Production workflows have been preserved: ${{ steps.preserve-workflows.outputs.preserved_count || '0' }} workflow(s)
          - All commits maintain full history (no squashing)

          ---

          ðŸ¤– Generated by [GitHub Actions](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          REMOVED_FILES_EOF

          # Expand environment variables in release notes
          envsubst < /tmp/release-notes.md > /tmp/release-notes-final.md

          echo "::notice::Release notes generated"
          echo "::group::Release Notes Preview"
          cat /tmp/release-notes-final.md
          echo "::endgroup::"

          echo "::endgroup::"

      - name: Push production branch to source repo
        run: |
          echo "::group::Push production branch"

          # Push production branch back to source repo
          git push origin production --force-with-lease

          echo "::notice::âœ… Pushed production branch to source repository"
          echo "::notice::View at: ${{ github.server_url }}/${{ github.repository }}/tree/production"

          echo "::endgroup::"

      - name: Push to production repository temp branch
        id: push-temp
        env:
          PRODUCTION_REPO: ${{ secrets.PRODUCTION_REPO }}
          PRODUCTION_BRANCH: ${{ secrets.PRODUCTION_BRANCH || 'main' }}
        run: |
          echo "::group::Push to production repository"

          # Generate temp branch name
          TEMP_BRANCH="production-sync-$(date -u '+%Y%m%d-%H%M%S')"
          echo "::notice::Creating temporary branch: $TEMP_BRANCH"
          echo "temp_branch=$TEMP_BRANCH" >> $GITHUB_OUTPUT

          # Push to production repo temp branch
          git push prod-repo production:"$TEMP_BRANCH"

          echo "::notice::âœ… Pushed to production repository temp branch: $TEMP_BRANCH"

          echo "::endgroup::"

      - name: Create Pull Request in production repository
        id: create-pr
        env:
          PRODUCTION_REPO: ${{ secrets.PRODUCTION_REPO }}
          PRODUCTION_BRANCH: ${{ secrets.PRODUCTION_BRANCH || 'main' }}
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          echo "::group::Create Pull Request"

          # Determine PR title
          if [ -n "${{ github.event.inputs.pr_title }}" ]; then
            PR_TITLE="${{ github.event.inputs.pr_title }}"
          else
            PR_TITLE="ðŸš€ Production Sync ${{ env.NEXT_VERSION }}"
          fi

          echo "::notice::Creating PR with title: $PR_TITLE"

          # Create PR in production repository
          PR_URL=$(gh pr create \
            --repo "${{ secrets.PRODUCTION_REPO }}" \
            --base "${{ secrets.PRODUCTION_BRANCH || 'main' }}" \
            --head "${{ steps.push-temp.outputs.temp_branch }}" \
            --title "$PR_TITLE" \
            --body-file /tmp/release-notes-final.md)

          echo "::notice::âœ… Pull Request created: $PR_URL"
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

          # Also save to job summary
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # ðŸš€ Production Sync Complete

          ## Pull Request Created

          **PR URL**: $PR_URL

          **Version**: ${{ env.NEXT_VERSION }}

          **Temp Branch**: \`${{ steps.push-temp.outputs.temp_branch }}\`

          ## Next Steps

          1. Review the Pull Request in the production repository
          2. Merge the PR when ready to deploy
          3. The version tag will be created automatically after merge

          ## Quick Links

          - [Production Repository](${{ github.server_url }}/${{ secrets.PRODUCTION_REPO }})
          - [Pull Request]($PR_URL)
          - [Source Commit](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})
          - [Production Branch](${{ github.server_url }}/${{ github.repository }}/tree/production)
          EOF

          echo "::endgroup::"

      - name: Cleanup
        if: always()
        run: |
          # Switch back to main branch
          git checkout main 2>/dev/null || true

          # Remove production repo remote
          git remote remove prod-repo 2>/dev/null || true

          echo "::notice::Cleanup completed"
