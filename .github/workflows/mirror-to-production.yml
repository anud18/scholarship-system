name: Mirror to Production Repo

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'ç‰ˆæœ¬éžå¢žé¡žåž‹ï¼ˆç”¨æ–¼ Release Notesï¼‰'
        required: false
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

      pr_title:
        description: 'Pull Request æ¨™é¡Œï¼ˆé¸å¡«ï¼Œé è¨­æœƒè‡ªå‹•ç”Ÿæˆï¼‰'
        required: false
        type: string

# SECURITY: Limit GITHUB_TOKEN permissions to minimum required
permissions:
  contents: write  # Need write for creating/updating production branch

jobs:
  sync-to-production:
    name: Sync to Production Repository
    runs-on: ubuntu-latest
    # Only run if secrets are configured
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for proper merging
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check for required secrets
        id: check-secrets
        run: |
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            echo "::error::GH_PAT secret not configured"
            echo "::error::Please configure GH_PAT with write access to production repo"
            exit 1
          fi

          if [ -z "${{ secrets.PRODUCTION_REPO }}" ]; then
            echo "::error::PRODUCTION_REPO secret not configured"
            echo "::error::Please set PRODUCTION_REPO to format: owner/repo-name"
            exit 1
          fi

          echo "configured=true" >> $GITHUB_OUTPUT

      - name: Initialize or switch to production branch
        run: |
          echo "::group::Initialize production branch"

          # Fetch all branches
          git fetch origin

          # Check if production branch exists locally or remotely
          if git show-ref --verify --quiet refs/heads/production; then
            echo "::notice::Production branch exists locally, checking out"
            git checkout production
          elif git show-ref --verify --quiet refs/remotes/origin/production; then
            echo "::notice::Production branch exists remotely, checking out"
            git checkout -b production origin/production
          else
            echo "::notice::Creating new production branch from main"
            git checkout -b production
          fi

          echo "::endgroup::"

      - name: Sync from production repository
        env:
          PRODUCTION_REPO: ${{ secrets.PRODUCTION_REPO }}
          PRODUCTION_BRANCH: ${{ secrets.PRODUCTION_BRANCH || 'main' }}
        run: |
          echo "::group::Syncing from production repository"

          # Add production repo as remote (for later push, not for merge)
          echo "::notice::Adding production repository as remote"
          git remote add prod-repo "https://x-access-token:${{ secrets.GH_PAT }}@github.com/${PRODUCTION_REPO}.git" 2>/dev/null || true

          # SKIP merge from production repo to avoid file content conflicts
          # The production repo contains squashed commits with same file states as dev repo
          # Merging would cause Git to think there are no new changes in Step 6
          echo "::notice::Skipping merge from production repository (not needed for one-way sync)"
          echo "PROD_SYNC_COMMITS=Skipped (one-way sync from dev to prod)" >> $GITHUB_ENV

          # Still fetch for reference (not for merge)
          if git fetch prod-repo "${PRODUCTION_BRANCH}" 2>/dev/null; then
            echo "::notice::Production repository fetched successfully (for reference only)"
          else
            echo "::notice::Production repository not found or first sync"
            echo "::notice::This is expected for first-time setup"
          fi

          echo "::endgroup::"

      - name: Merge latest from main branch
        run: |
          echo "::group::Merging latest from main"

          # Get current HEAD before merge
          BEFORE_MERGE=$(git rev-parse HEAD)

          # Fetch and merge main
          git fetch origin main
          echo "::notice::Merging latest changes from main branch"

          if git merge origin/main --allow-unrelated-histories -X theirs -m "chore: merge latest from main

          Merged latest development changes from main branch
          Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          " 2>&1 | tee /tmp/merge-main-output.txt; then
            # Merge succeeded
            AFTER_MERGE=$(git rev-parse HEAD)
            if [ "$BEFORE_MERGE" != "$AFTER_MERGE" ]; then
              echo "::notice::âœ… Merged changes from main"

              # Show what was merged
              echo "::notice::Changes from main:"
              git log --oneline "${BEFORE_MERGE}..${AFTER_MERGE}" | head -10 || true

              # Save for release notes
              echo "MAIN_MERGE_COMMITS<<EOF" >> $GITHUB_ENV
              git log --format="- %s (%an, %ar)" "${BEFORE_MERGE}..origin/main" | head -20
              echo "EOF" >> $GITHUB_ENV
            else
              echo "::notice::No new changes from main branch"
              echo "MAIN_MERGE_COMMITS=No new changes from main" >> $GITHUB_ENV
            fi
          else
            # Merge failed - auto-resolve conflicts
            echo "::warning::Merge encountered conflicts, auto-resolving..."

            # Check if conflict is in .github/workflows/
            if grep -q ".github/workflows/" /tmp/merge-main-output.txt; then
              echo "::notice::Detected .github/workflows/ conflict (expected)"
              echo "::notice::Accepting main's version (will be removed in next step)"
            fi

            # Accept main's version for all conflicts
            # This is safe because:
            # 1. .github/workflows/ will be removed in next step anyway
            # 2. Other files should take the latest version from main
            git checkout --theirs . 2>/dev/null || true
            git add -A

            if git commit -m "chore: merge latest from main (auto-resolved conflicts)

            Merged latest development changes from main branch
            Conflicts auto-resolved by accepting main's version
            Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            "; then
              echo "::notice::âœ… Conflicts resolved and committed"

              # Save for release notes
              AFTER_MERGE=$(git rev-parse HEAD)
              echo "MAIN_MERGE_COMMITS<<EOF" >> $GITHUB_ENV
              git log --format="- %s (%an, %ar)" "${BEFORE_MERGE}..origin/main" | head -20
              echo "(Conflicts auto-resolved)"
              echo "EOF" >> $GITHUB_ENV
            else
              echo "::notice::No conflicts to resolve (clean state)"
              echo "MAIN_MERGE_COMMITS=No new changes from main" >> $GITHUB_ENV
            fi
          fi

          echo "::endgroup::"

      - name: Remove development workflows
        run: |
          echo "::group::Removing development workflows"

          # Remove .github/workflows directory
          if [ -d ".github/workflows" ]; then
            echo "::notice::Removing .github/workflows/ directory"

            # List files being removed
            echo "::notice::Files to be removed:"
            find .github/workflows -type f -name "*.yml" -o -name "*.yaml" | tee /tmp/removed-workflows.txt

            git rm -rf .github/workflows/

            # Count removed files
            REMOVED_COUNT=$(wc -l < /tmp/removed-workflows.txt || echo "0")
            echo "::notice::Removed $REMOVED_COUNT workflow file(s)"
            echo "REMOVED_WORKFLOWS_COUNT=$REMOVED_COUNT" >> $GITHUB_ENV

            # Save list for release notes
            echo "REMOVED_WORKFLOWS<<EOF" >> $GITHUB_ENV
            cat /tmp/removed-workflows.txt || echo "None"
            echo "EOF" >> $GITHUB_ENV
          else
            echo "::notice::No .github/workflows/ directory found"
            echo "REMOVED_WORKFLOWS_COUNT=0" >> $GITHUB_ENV
            echo "REMOVED_WORKFLOWS=No workflows to remove" >> $GITHUB_ENV
          fi

          # If .github directory is now empty, remove it
          if [ -d ".github" ] && [ -z "$(ls -A .github 2>/dev/null)" ]; then
            echo "::notice::Removing empty .github/ directory"
            git rm -rf .github/
          fi

          # Commit the removal
          if git diff --cached --quiet; then
            echo "::notice::No workflows to remove"
          else
            git commit -m "chore: remove development workflows for production

            Development workflows are not needed in production repository.
            Production repo will maintain its own deployment and monitoring workflows.

            Removed workflows: ${REMOVED_WORKFLOWS_COUNT} files
            Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            "
            echo "::notice::âœ… Committed workflow removal"
          fi

          echo "::endgroup::"

      - name: Remove development-only directories
        run: |
          echo "::group::Removing development-only directories"

          REMOVED_DIRS=""

          # Remove .github/codeql directory
          if [ -d ".github/codeql" ]; then
            echo "::notice::Removing .github/codeql/ directory"
            git rm -rf .github/codeql/
            REMOVED_DIRS="${REMOVED_DIRS}- .github/codeql/ (CodeQL configuration)\n"
          fi

          # Remove .github/production-workflows-examples directory
          if [ -d ".github/production-workflows-examples" ]; then
            echo "::notice::Removing .github/production-workflows-examples/ directory"
            git rm -rf .github/production-workflows-examples/
            REMOVED_DIRS="${REMOVED_DIRS}- .github/production-workflows-examples/ (Production workflows examples)\n"
          fi

          # Remove mock-student-api (development only)
          if [ -d "mock-student-api" ]; then
            echo "::notice::Removing mock-student-api/ directory"
            git rm -rf mock-student-api/
            REMOVED_DIRS="${REMOVED_DIRS}- mock-student-api/ (Mock Student API)\n"
          fi

          # Remove .claude directory (Claude Code project configuration)
          if [ -d ".claude" ]; then
            echo "::notice::Removing .claude/ directory"
            git rm -rf .claude/
            REMOVED_DIRS="${REMOVED_DIRS}- .claude/ (Claude Code configuration)\n"
          fi

          # Remove docker-compose variants (keep only monitoring if needed)
          echo "::notice::Removing docker-compose variant files"
          for file in docker-compose.*.yml; do
            if [ -f "$file" ]; then
              echo "::notice::Removing $file"
              git rm "$file" 2>/dev/null || true
              REMOVED_DIRS="${REMOVED_DIRS}- $file (Docker Compose variant)\n"
            fi
          done

          # Remove subdirectory docker-compose files (except monitoring)
          find . -type f -name "docker-compose*.yml" 2>/dev/null | while read file; do
            if [[ "$file" != "./monitoring/"* ]]; then
              echo "::notice::Removing $file"
              git rm "$file" 2>/dev/null || true
              REMOVED_DIRS="${REMOVED_DIRS}- $file (Docker Compose file)\n"
            fi
          done

          # Remove test directories
          echo "::notice::Removing test directories"
          git rm -rf frontend/__tests__/ 2>/dev/null || true
          git rm -rf frontend/components/__tests__/ 2>/dev/null || true
          git rm -rf frontend/hooks/__tests__/ 2>/dev/null || true
          git rm -rf frontend/lib/__tests__/ 2>/dev/null || true
          git rm -rf frontend/lib/api/__tests__/ 2>/dev/null || true
          git rm -rf frontend/lib/utils/__tests__/ 2>/dev/null || true
          git rm -rf backend/app/tests/ 2>/dev/null || true

          if git diff --cached --quiet --name-only | grep -q "__tests__\|/tests/"; then
            REMOVED_DIRS="${REMOVED_DIRS}- Test directories (__tests__/, tests/)\n"
          fi

          # Remove test files
          echo "::notice::Removing test files"
          find . -type f \( -name "*.test.ts" -o -name "*.test.tsx" -o -name "*.test.py" -o -name "test_*.py" \) 2>/dev/null | \
            xargs -r git rm -f 2>/dev/null || true

          if git diff --cached --quiet --name-only | grep -q "\.test\.\|test_"; then
            REMOVED_DIRS="${REMOVED_DIRS}- Test files (*.test.*, test_*.py)\n"
          fi

          # Remove test configuration files
          echo "::notice::Removing test configuration files"
          git rm -f frontend/jest.config.js 2>/dev/null || true
          git rm -f frontend/jest.config.standalone.js 2>/dev/null || true
          git rm -f frontend/tsconfig.test.json 2>/dev/null || true
          git rm -f backend/pytest.ini 2>/dev/null || true
          git rm -f backend/.coverage 2>/dev/null || true

          if git diff --cached --quiet --name-only | grep -q "jest.config\|pytest.ini\|\.coverage"; then
            REMOVED_DIRS="${REMOVED_DIRS}- Test configuration files\n"
          fi

          # Remove all markdown documentation files
          echo "::notice::Removing markdown documentation files"
          find . -type f -name "*.md" 2>/dev/null | xargs -r git rm -f 2>/dev/null || true

          if git diff --cached --quiet --name-only | grep -q "\.md$"; then
            REMOVED_DIRS="${REMOVED_DIRS}- Documentation files (*.md)\n"
          fi

          # Save for release notes
          if [ -n "$REMOVED_DIRS" ]; then
            echo "REMOVED_DIRS<<EOF" >> $GITHUB_ENV
            echo -e "$REMOVED_DIRS" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "REMOVED_DIRS=No development directories to remove" >> $GITHUB_ENV
          fi

          # Commit the removal
          if git diff --cached --quiet; then
            echo "::notice::No development directories to remove"
          else
            git commit -m "chore: remove development-only directories for production

            Development directories are not needed in production:
            $(echo -e "$REMOVED_DIRS")

            Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            "
            echo "::notice::âœ… Committed development directories removal"
          fi

          echo "::endgroup::"

      - name: Preserve production workflows
        id: preserve-workflows
        continue-on-error: true
        env:
          PRODUCTION_REPO: ${{ secrets.PRODUCTION_REPO }}
          PRODUCTION_BRANCH: ${{ secrets.PRODUCTION_BRANCH || 'main' }}
        run: |
          echo "::group::Preserving production workflows"

          # Try to fetch production workflows
          echo "::notice::Fetching production workflows..."
          if git ls-tree -r prod-repo/${PRODUCTION_BRANCH} --name-only 2>/dev/null | grep -q "^.github/workflows/"; then
            echo "::notice::Production has workflows, preserving them..."

            # Create temp directory
            mkdir -p /tmp/production-workflows

            # Extract production workflows to temp
            git archive prod-repo/${PRODUCTION_BRANCH} .github/workflows | tar -x -C /tmp/production-workflows 2>/dev/null || true

            # Copy production workflows back
            if [ -d "/tmp/production-workflows/.github/workflows" ]; then
              mkdir -p .github/workflows
              cp -r /tmp/production-workflows/.github/workflows/* .github/workflows/ 2>/dev/null || true

              WORKFLOW_COUNT=$(find .github/workflows -type f \( -name "*.yml" -o -name "*.yaml" \) 2>/dev/null | wc -l)
              echo "::notice::âœ… Preserved $WORKFLOW_COUNT production workflow(s)"

              # List preserved workflows
              echo "::notice::Preserved workflows:"
              find .github/workflows -type f \( -name "*.yml" -o -name "*.yaml" \) -exec basename {} \; || true

              # Add to git
              git add .github/workflows/

              # Commit preservation
              if ! git diff --cached --quiet; then
                git commit -m "chore: preserve production workflows

                Preserved ${WORKFLOW_COUNT} workflow(s) from production repository
                Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
                "
                echo "::notice::âœ… Production workflows preserved and committed"
              fi

              echo "preserved_count=$WORKFLOW_COUNT" >> $GITHUB_OUTPUT
            else
              echo "::notice::No production workflows found to preserve"
              echo "preserved_count=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "::notice::Production repo has no .github/workflows/ directory"
            echo "preserved_count=0" >> $GITHUB_OUTPUT
          fi

          # Cleanup temp directory
          rm -rf /tmp/production-workflows

          echo "::endgroup::"

      - name: Calculate next version
        id: version
        env:
          VERSION_BUMP: ${{ github.event.inputs.version_bump || 'patch' }}
        run: |
          echo "::group::Calculate next version"

          # Fetch tags from production repo
          git fetch prod-repo --tags 2>/dev/null || true

          # Get latest semantic version tag
          LATEST_TAG=$(git tag -l "v*.*.*" --sort=-v:refname | head -1 || echo "")

          if [ -z "$LATEST_TAG" ]; then
            echo "::notice::No previous version found, starting with v0.9.0"
            NEXT_VERSION="v0.9.0"
          else
            echo "::notice::Latest version: $LATEST_TAG"

            # Parse version (remove 'v' prefix)
            VERSION=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

            # Increment based on bump type
            case "$VERSION_BUMP" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "::notice::Next version: $NEXT_VERSION"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "NEXT_VERSION=$NEXT_VERSION" >> $GITHUB_ENV

          echo "::endgroup::"

      - name: Generate release notes
        id: release-notes
        run: |
          echo "::group::Generate release notes"

          # Pre-calculate sync date for use in heredoc
          SYNC_DATE=$(date -u '+%Y-%m-%d %H:%M:%S UTC')

          # Create release notes file
          cat > /tmp/release-notes.md <<RELEASE_NOTES_EOF
          <!-- AUTO_TAG_METADATA
          Version: ${{ env.NEXT_VERSION }}
          -->

          # ðŸš€ Production Sync ${{ env.NEXT_VERSION }}

          ## ðŸ“‹ Summary

          This release syncs the latest changes from the development repository to production.

          | Property | Value |
          |----------|-------|
          | **Version** | ${{ env.NEXT_VERSION }} |
          | **Source Repo** | [${{ github.repository }}](https://github.com/${{ github.repository }}) |
          | **Source Commit** | [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }}) |
          | **Sync Date** | ${SYNC_DATE} |
          | **Triggered By** | @${{ github.actor }} |

          ## ðŸ”„ Changes Synced from Production Repository

          ${{ env.PROD_SYNC_COMMITS }}

          ## âœ¨ Changes Merged from Main Branch

          ${{ env.MAIN_MERGE_COMMITS }}

          ## ðŸ“Š File Changes

          RELEASE_NOTES_EOF

          # Add file statistics placeholder (will be calculated after squashing)
          echo "" >> /tmp/release-notes.md
          echo "\`\`\`" >> /tmp/release-notes.md
          echo "PLACEHOLDER_FILE_STATS" >> /tmp/release-notes.md
          echo "\`\`\`" >> /tmp/release-notes.md

          # Add excluded/removed development files information
          cat >> /tmp/release-notes.md <<REMOVED_FILES_EOF

          ## ðŸš« Excluded Development Files

          ### Workflows Removed
          ${{ env.REMOVED_WORKFLOWS }}

          ### Directories Removed
          ${{ env.REMOVED_DIRS }}

          ### Files Excluded from Sync (Not Deleted)
          - All test directories: `frontend/__tests__/`, `frontend/*/â€Œ__tests__/`, `backend/app/tests/`
          - All test files: `*.test.tsx`, `*.test.ts`, `*.test.py`, `test_*.py`
          - Test configuration: `jest.config.js`, `pytest.ini`, `tsconfig.test.json`, `.coverage`
          - Docker compose variants: `docker-compose.*.yml`
          - Documentation files: `*.md` (README, CONTRIBUTING, etc.)

          ## ðŸ“ Notes

          - This is a production-ready snapshot with development files excluded or removed
          - Test files remain in development repository but are excluded from production sync
          - Production workflows have been preserved: ${{ steps.preserve-workflows.outputs.preserved_count || '0' }} workflow(s)
          - All changes squashed into a single clean commit for production

          ___

          ðŸ¤– Generated by [GitHub Actions](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          REMOVED_FILES_EOF

          # Expand environment variables in release notes
          envsubst < /tmp/release-notes.md > /tmp/release-notes-final.md

          echo "::notice::Release notes generated"
          echo "::group::Release Notes Preview"
          cat /tmp/release-notes-final.md
          echo "::endgroup::"

          echo "::endgroup::"

      - name: Squash all changes into single commit
        id: squash-commit
        env:
          NEXT_VERSION: ${{ env.NEXT_VERSION }}
        run: |
          echo "::group::Squashing all changes into single commit"

          # Get current tree (all file states)
          CURRENT_TREE=$(git write-tree)
          echo "::notice::Current tree: $CURRENT_TREE"

          # Use origin/production as the baseline (not prod-repo/main)
          # This ensures we calculate diff from last sync, not from production repo's current state
          PROD_LATEST=$(git rev-parse origin/production 2>/dev/null || echo "")

          # Prepare commit message using generated release notes
          echo "Release $NEXT_VERSION" > /tmp/squash-commit-msg.txt
          echo "" >> /tmp/squash-commit-msg.txt
          cat /tmp/release-notes-final.md >> /tmp/squash-commit-msg.txt
          echo "" >> /tmp/squash-commit-msg.txt
          echo "___" >> /tmp/squash-commit-msg.txt
          echo "" >> /tmp/squash-commit-msg.txt
          echo "This commit squashes all development changes into a single release" >> /tmp/squash-commit-msg.txt
          echo "Full development history available in source repository" >> /tmp/squash-commit-msg.txt

          # Create new squashed commit
          if [ -n "$PROD_LATEST" ]; then
            # Based on production repo (maintaining continuity)
            NEW_COMMIT=$(git commit-tree $CURRENT_TREE -p $PROD_LATEST -F /tmp/squash-commit-msg.txt)
            echo "::notice::Created squashed commit based on prod-repo/main"
            echo "::notice::Parent commit: $PROD_LATEST"
          else
            # First sync - no parent
            NEW_COMMIT=$(git commit-tree $CURRENT_TREE -F /tmp/squash-commit-msg.txt)
            echo "::notice::Created initial squashed commit (no parent)"
          fi

          echo "::notice::New commit: $NEW_COMMIT"

          # Reset production branch to new commit
          git reset --hard $NEW_COMMIT

          echo "::notice::âœ… All changes squashed into single commit"
          echo "::notice::Commit SHA: $NEW_COMMIT"
          echo "squashed_commit=$NEW_COMMIT" >> $GITHUB_OUTPUT

          # Show commit info
          echo "::group::Squashed Commit Details"
          git log -1 --stat
          echo "::endgroup::"

          echo "::endgroup::"

      - name: Calculate actual file changes
        run: |
          echo "::group::Calculate actual file statistics"

          # Use origin/production as baseline (consistent with squash step)
          PROD_LATEST=$(git rev-parse origin/production 2>/dev/null || echo "")

          if [ -n "$PROD_LATEST" ]; then
            # Calculate diff between production's latest and current HEAD (squashed commit)
            # Exclude development-only files
            FILE_STATS=$(git diff --stat $PROD_LATEST..HEAD -- \
              ':!.github/codeql' \
              ':!.github/workflows' \
              ':!.github/production-workflows-examples' \
              ':!.claude' \
              ':!mock-student-api' \
              ':!frontend/__tests__/**' \
              ':!frontend/components/__tests__/**' \
              ':!frontend/hooks/__tests__/**' \
              ':!frontend/lib/__tests__/**' \
              ':!frontend/lib/api/__tests__/**' \
              ':!frontend/lib/utils/__tests__/**' \
              ':!backend/app/tests/**' \
              ':!**/*.test.tsx' \
              ':!**/*.test.ts' \
              ':!**/*.test.py' \
              ':!**/test_*.py' \
              ':!frontend/jest.config.js' \
              ':!frontend/jest.config.standalone.js' \
              ':!frontend/tsconfig.test.json' \
              ':!backend/pytest.ini' \
              ':!backend/.coverage' \
              ':!docker-compose.*.yml' \
              ':!backend/docker-compose.yml' \
              ':!**/docker-compose.yml' \
              ':!**/*.md' \
              | tail -1)

            # Handle case where there are no changes
            if [ -z "$FILE_STATS" ] || [ "$FILE_STATS" = "" ]; then
              FILE_STATS="No file changes"
            fi

            echo "::notice::File statistics: $FILE_STATS"
          else
            # First sync - compare to empty tree
            FILE_STATS=$(git diff --stat $(git hash-object -t tree /dev/null)..HEAD -- \
              ':!.github/codeql' \
              ':!.github/workflows' \
              ':!.github/production-workflows-examples' \
              ':!.claude' \
              ':!mock-student-api' \
              ':!frontend/__tests__/**' \
              ':!frontend/components/__tests__/**' \
              ':!frontend/hooks/__tests__/**' \
              ':!frontend/lib/__tests__/**' \
              ':!frontend/lib/api/__tests__/**' \
              ':!frontend/lib/utils/__tests__/**' \
              ':!backend/app/tests/**' \
              ':!**/*.test.tsx' \
              ':!**/*.test.ts' \
              ':!**/*.test.py' \
              ':!**/test_*.py' \
              ':!frontend/jest.config.js' \
              ':!frontend/jest.config.standalone.js' \
              ':!frontend/tsconfig.test.json' \
              ':!backend/pytest.ini' \
              ':!backend/.coverage' \
              ':!docker-compose.*.yml' \
              ':!backend/docker-compose.yml' \
              ':!**/docker-compose.yml' \
              ':!**/*.md' \
              | tail -1 || echo "Initial commit")
            echo "::notice::First sync - file statistics: $FILE_STATS"
          fi

          # Update release notes with actual file statistics
          # Use a different sed delimiter to avoid issues with special characters
          FILE_STATS_ESCAPED=$(echo "$FILE_STATS" | sed 's/[&/\]/\\&/g')
          sed -i "s|PLACEHOLDER_FILE_STATS|$FILE_STATS_ESCAPED|" /tmp/release-notes.md

          # Regenerate final release notes with environment variables expanded
          envsubst < /tmp/release-notes.md > /tmp/release-notes-final.md

          echo "::notice::âœ… Release notes updated with actual file statistics"
          echo "::group::Updated Release Notes Preview"
          cat /tmp/release-notes-final.md
          echo "::endgroup::"

          echo "::endgroup::"

      - name: Push production branch to source repo
        run: |
          echo "::group::Push production branch"

          # Push production branch back to source repo
          # Note: Using --force because we squashed commits
          git push origin production --force

          echo "::notice::âœ… Pushed squashed production branch to source repository"
          echo "::notice::View at: ${{ github.server_url }}/${{ github.repository }}/tree/production"
          echo "::notice::âš ï¸  Note: This is a force push due to commit squashing"

          echo "::endgroup::"

      - name: Push to production repository temp branch
        id: push-temp
        env:
          PRODUCTION_REPO: ${{ secrets.PRODUCTION_REPO }}
          PRODUCTION_BRANCH: ${{ secrets.PRODUCTION_BRANCH || 'main' }}
        run: |
          echo "::group::Push to production repository"

          # Generate temp branch name
          TEMP_BRANCH="production-sync-$(date -u '+%Y%m%d-%H%M%S')"
          echo "::notice::Creating temporary branch: $TEMP_BRANCH"
          echo "temp_branch=$TEMP_BRANCH" >> $GITHUB_OUTPUT

          # Push to production repo temp branch
          git push prod-repo production:"$TEMP_BRANCH"

          echo "::notice::âœ… Pushed to production repository temp branch: $TEMP_BRANCH"

          echo "::endgroup::"

      - name: Create Pull Request in production repository
        id: create-pr
        env:
          PRODUCTION_REPO: ${{ secrets.PRODUCTION_REPO }}
          PRODUCTION_BRANCH: ${{ secrets.PRODUCTION_BRANCH || 'main' }}
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          echo "::group::Create Pull Request"

          # Determine PR title (standardized format for auto-tagging)
          if [ -n "${{ github.event.inputs.pr_title }}" ]; then
            PR_TITLE="${{ github.event.inputs.pr_title }}"
          else
            PR_TITLE="Release ${{ env.NEXT_VERSION }}"
          fi

          echo "::notice::Creating PR with title: $PR_TITLE"

          # Create PR in production repository
          PR_URL=$(gh pr create \
            --repo "${{ secrets.PRODUCTION_REPO }}" \
            --base "${{ secrets.PRODUCTION_BRANCH || 'main' }}" \
            --head "${{ steps.push-temp.outputs.temp_branch }}" \
            --title "$PR_TITLE" \
            --body-file /tmp/release-notes-final.md)

          echo "::notice::âœ… Pull Request created: $PR_URL"
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

          # Also save to job summary
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # ðŸš€ Production Sync Complete

          ## Pull Request Created

          **PR URL**: $PR_URL

          **Version**: ${{ env.NEXT_VERSION }}

          **Temp Branch**: \`${{ steps.push-temp.outputs.temp_branch }}\`

          ## Next Steps

          1. Review the Pull Request in the production repository
          2. Merge the PR (using squash merge) when ready to deploy
          3. **The version tag will be created automatically** after PR merge (requires auto-tag workflow in production repo)

          ## ðŸ·ï¸ Auto-Tagging Information

          - **Tag Format**: \`${{ env.NEXT_VERSION }}\` (e.g., v1.2.3)
          - **PR Title Format**: \`Release ${{ env.NEXT_VERSION }}\`
          - **Metadata in PR Body**: Version information embedded for extraction
          - **Recommended**: Set up auto-tag workflow in production repository (see production-workflows-examples/)

          ## Quick Links

          - [Production Repository](${{ github.server_url }}/${{ secrets.PRODUCTION_REPO }})
          - [Pull Request]($PR_URL)
          - [Source Commit](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})
          - [Production Branch](${{ github.server_url }}/${{ github.repository }}/tree/production)
          EOF

          echo "::endgroup::"

      - name: Cleanup
        if: always()
        run: |
          # Switch back to main branch
          git checkout main 2>/dev/null || true

          # Remove production repo remote
          git remote remove prod-repo 2>/dev/null || true

          echo "::notice::Cleanup completed"
