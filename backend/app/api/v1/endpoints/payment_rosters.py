"""
Payment roster API endpoints
造冊相關API端點
"""

import logging
import os
from datetime import datetime, timedelta
from typing import Optional

from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, Query, status
from fastapi.responses import FileResponse
from sqlalchemy import and_, select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Session, selectinload
from sqlalchemy.sql.functions import count

from app.core.deps import get_current_user
from app.core.exceptions import RosterAlreadyExistsError, RosterGenerationError, RosterLockedError, RosterNotFoundError
from app.core.path_security import validate_object_name_minio
from app.core.security import check_user_roles
from app.db.deps import get_db, get_sync_db
from app.models.payment_roster import (
    PaymentRoster,
    PaymentRosterItem,
    RosterStatus,
    RosterTriggerType,
    StudentVerificationStatus,
)
from app.models.user import User, UserRole
from app.schemas.response import ApiResponse
from app.schemas.roster import (
    RosterAuditLogResponse,
    RosterCreateRequest,
    RosterExportRequest,
    RosterItemResponse,
    RosterListResponse,
    RosterResponse,
    RosterStatisticsResponse,
)
from app.services.excel_export_service import ExcelExportService
from app.services.roster_service import RosterService
from app.utils.academic_period import get_roster_period_dates

logger = logging.getLogger(__name__)

router = APIRouter()


@router.post("/generate")
def generate_payment_roster(
    request: RosterCreateRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    產生造冊
    Generate payment roster
    """
    # 檢查權限：只有管理員和處理人員可以產生造冊
    check_user_roles([UserRole.admin, UserRole.super_admin], current_user)

    try:
        roster_service = RosterService(db)

        # 產生造冊（返回 PaymentRoster 對象）
        roster = roster_service.generate_roster(
            scholarship_configuration_id=request.scholarship_configuration_id,
            period_label=request.period_label,
            roster_cycle=request.roster_cycle,
            academic_year=request.academic_year,
            created_by_user_id=current_user.id,
            trigger_type=RosterTriggerType.MANUAL,
            student_verification_enabled=request.student_verification_enabled,
            ranking_id=request.ranking_id,  # 新增：傳遞排名ID
        )

        logger.info(f"Roster {roster.roster_code} generated by user {current_user.id}")

        # Auto-export Excel if requested
        excel_export_result = None
        if request.auto_export_excel:
            try:
                export_service = ExcelExportService()
                excel_export_result = export_service.export_roster_to_excel(
                    roster=roster,
                    template_name="STD_UP_MIXLISTA",
                    include_header=True,
                    include_statistics=True,
                    include_excluded=False,
                )
                db.commit()  # Commit the roster with minio_object_name
                logger.info(
                    f"Excel file automatically exported for roster {roster.roster_code}: "
                    f"{excel_export_result.get('minio_object_name', 'N/A')}"
                )
            except Exception as export_error:
                logger.error(f"Auto-export failed for roster {roster.roster_code}: {export_error}", exc_info=True)
                # Don't fail roster generation if export fails
                excel_export_result = {"error": str(export_error)}

        # 造冊產生成功
        message = "造冊產生成功"
        if excel_export_result and "error" not in excel_export_result:
            message += "，Excel檔案已自動產生並上傳"

        response_data = RosterResponse.from_orm(roster)
        response_dict = response_data.model_dump() if hasattr(response_data, "model_dump") else response_data.dict()

        # Include export result if available
        if excel_export_result:
            response_dict["excel_export"] = excel_export_result

        return {
            "success": True,
            "message": message,
            "data": response_dict,
        }

    except RosterAlreadyExistsError as e:
        # Roster already exists for this configuration/period
        logger.warning(f"Roster already exists: {e}")
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))

    except RosterLockedError as e:
        # Trying to regenerate a locked roster
        logger.warning(f"Roster is locked: {e}")
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))

    except RosterNotFoundError as e:
        # Referenced roster not found (for regeneration)
        logger.warning(f"Roster not found: {e}")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

    except RosterGenerationError as e:
        # General roster generation failure
        logger.error(f"Roster generation error: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

    except ValueError as e:
        # Validation errors (missing data, invalid parameters)
        logger.warning(f"Roster generation validation error: {e}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

    except Exception as e:
        # Unexpected errors
        logger.error(f"Unexpected error generating roster: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to generate roster: {str(e)}"
        )


@router.get("/available-rankings")
def get_available_rankings(
    scholarship_configuration_id: int = Query(..., description="獎學金配置ID"),
    academic_year: int = Query(..., description="學年度"),
    semester: Optional[str] = Query(None, description="學期"),
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    查詢可用於造冊的排名清單
    Get available rankings for roster generation

    Returns rankings that have executed distribution and can be used for roster creation.
    """
    from app.models.college_review import CollegeRanking
    from app.models.scholarship import ScholarshipConfiguration

    # 檢查權限
    check_user_roles([UserRole.admin, UserRole.super_admin], current_user)

    try:
        # 驗證配置存在
        config = (
            db.query(ScholarshipConfiguration)
            .filter(ScholarshipConfiguration.id == scholarship_configuration_id)
            .first()
        )

        if not config:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Scholarship configuration {scholarship_configuration_id} not found",
            )

        # 查詢已執行分配的排名
        query = db.query(CollegeRanking).filter(
            and_(
                CollegeRanking.scholarship_type_id == config.scholarship_type_id,
                CollegeRanking.academic_year == academic_year,
                CollegeRanking.distribution_executed == True,  # 必須已執行分配
            )
        )

        # 學期篩選
        if semester:
            query = query.filter(CollegeRanking.semester == semester)
        else:
            query = query.filter(CollegeRanking.semester.is_(None))

        rankings = query.order_by(CollegeRanking.distribution_date.desc()).all()

        # 格式化回應
        ranking_list = [
            {
                "id": r.id,
                "ranking_name": r.ranking_name,
                "sub_type_code": r.sub_type_code,
                "total_applications": r.total_applications,
                "allocated_count": r.allocated_count,
                "distribution_date": r.distribution_date.isoformat() if r.distribution_date else None,
                "is_finalized": r.is_finalized,
                "ranking_status": r.ranking_status,
            }
            for r in rankings
        ]

        return {
            "success": True,
            "message": f"Found {len(ranking_list)} available rankings",
            "data": {
                "rankings": ranking_list,
                "scholarship_configuration_id": scholarship_configuration_id,
                "academic_year": academic_year,
                "semester": semester,
            },
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching available rankings: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to fetch available rankings"
        )


@router.get("")
async def list_payment_rosters(
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=100),
    scholarship_configuration_id: Optional[int] = Query(None),
    status_filter: Optional[RosterStatus] = Query(None),
    period_label: Optional[str] = Query(None),
    academic_year: Optional[int] = Query(None),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊清單
    Get payment roster list
    """
    try:
        # Build query with eager loading to avoid MissingGreenlet errors
        stmt = select(PaymentRoster).options(
            selectinload(PaymentRoster.items),
            selectinload(PaymentRoster.audit_logs),
            selectinload(PaymentRoster.creator),
            selectinload(PaymentRoster.locker),
            selectinload(PaymentRoster.scholarship_configuration),  # 增加獎學金配置的 eager loading
        )

        # 套用篩選條件
        if scholarship_configuration_id:
            stmt = stmt.where(PaymentRoster.scholarship_configuration_id == scholarship_configuration_id)
        if status_filter:
            stmt = stmt.where(PaymentRoster.status == status_filter)
        if period_label:
            stmt = stmt.where(PaymentRoster.period_label == period_label)
        if academic_year:
            stmt = stmt.where(PaymentRoster.academic_year == academic_year)

        # 計算總數
        count_stmt = select(count()).select_from(stmt.subquery())
        total_result = await db.execute(count_stmt)
        total = total_result.scalar()

        # 套用分頁
        stmt = stmt.order_by(PaymentRoster.created_at.desc()).offset(skip).limit(limit)
        result = await db.execute(stmt)
        rosters = result.scalars().all()

        # 手動構造回應字典以正確映射字段名稱
        roster_responses = []
        for roster in rosters:
            roster_dict = {
                "id": roster.id,
                "roster_code": roster.roster_code,
                "scholarship_configuration_id": roster.scholarship_configuration_id,
                "period_label": roster.period_label,
                "roster_cycle": roster.roster_cycle,
                "academic_year": roster.academic_year,
                "status": roster.status,
                "trigger_type": roster.trigger_type,
                "qualified_count": roster.qualified_count,
                "disqualified_count": roster.disqualified_count,
                "total_amount": roster.total_amount,
                "created_by_user_id": roster.created_by,  # 字段名稱映射
                "created_at": roster.created_at,
                "updated_at": roster.updated_at,
                "locked_at": roster.locked_at,
                "locked_by_user_id": roster.locked_by,
                # 前端需要的額外欄位
                "scholarship_config_name": (
                    roster.scholarship_configuration.config_name if roster.scholarship_configuration else None
                ),
                "student_count": roster.qualified_count + roster.disqualified_count,
                "roster_name": roster.roster_code,  # 前端使用 roster_name
                "roster_period": roster.roster_cycle.value,  # 前端使用 roster_period
                # Optional relationships (已 eager loaded，避免 MissingGreenlet)
                "items": [RosterItemResponse.from_orm(item) for item in roster.items] if roster.items else None,
                "audit_logs": (
                    [RosterAuditLogResponse.from_orm(log) for log in roster.audit_logs] if roster.audit_logs else None
                ),
            }
            roster_responses.append(RosterResponse(**roster_dict))

        response_data = RosterListResponse(items=roster_responses, total=total or 0, skip=skip, limit=limit)
        return ApiResponse(
            success=True,
            message="查詢成功",
            data=response_data.model_dump() if hasattr(response_data, "model_dump") else response_data.dict(),
        )

    except Exception as e:
        logger.error(f"Failed to list rosters: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得造冊清單失敗")


@router.get("/preview-students")
async def preview_roster_students(
    config_id: int = Query(..., description="獎學金配置ID"),
    ranking_id: Optional[int] = Query(None, description="排名ID (如有 Matrix Distribution)"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    預覽造冊學生名單
    Preview student list for roster generation

    Returns:
        - has_matrix_distribution: 是否有 Matrix 分配
        - allocated_students: 正取學生列表
        - summary: 統計摘要
    """
    check_user_roles([UserRole.admin, UserRole.super_admin], current_user)

    try:
        from app.models.application import Application
        from app.models.college_review import CollegeRanking, CollegeRankingItem
        from app.models.scholarship import ScholarshipConfiguration

        # Get scholarship configuration
        stmt = select(ScholarshipConfiguration).where(ScholarshipConfiguration.id == config_id)
        result = await db.execute(stmt)
        config = result.scalar_one_or_none()

        if not config:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到獎學金配置")

        # Check if has matrix distribution
        has_matrix_distribution = bool(config.has_college_quota and config.quotas)

        # If no ranking_id provided, try to find the latest ranking for this config
        if has_matrix_distribution and not ranking_id:
            stmt = (
                select(CollegeRanking)
                .where(
                    and_(
                        CollegeRanking.scholarship_type_id == config.scholarship_type_id,
                        CollegeRanking.distribution_executed == True,
                    )
                )
                .order_by(CollegeRanking.created_at.desc())
            )
            result = await db.execute(stmt)
            ranking = result.scalar_one_or_none()
            if ranking:
                ranking_id = ranking.id

        allocated_students = []
        summary = {
            "total_allocated": 0,
            "total_amount": 0.0,
            "by_college": {},
        }

        if ranking_id:
            # Get allocated students from CollegeRankingItem
            stmt = (
                select(CollegeRankingItem)
                .options(selectinload(CollegeRankingItem.application))
                .where(
                    and_(
                        CollegeRankingItem.ranking_id == ranking_id,
                        CollegeRankingItem.is_allocated == True,
                    )
                )
                .order_by(CollegeRankingItem.rank_position)
            )
            result = await db.execute(stmt)
            ranking_items = result.scalars().all()

            for item in ranking_items:
                application = item.application
                if not application:
                    continue

                student_data = application.student_data or {}
                college = student_data.get("std_academyno", "Unknown")

                student_info = {
                    "application_id": application.id,
                    "student_name": student_data.get("std_cname", ""),
                    "student_id": student_data.get("std_stdcode", ""),
                    "student_id_number": student_data.get("std_pid", ""),
                    "email": student_data.get("com_email", ""),
                    "college": college,
                    "department": student_data.get("std_depno", ""),
                    "term_count": student_data.get("trm_termcount", ""),
                    "sub_type": item.allocated_sub_type,
                    "amount": float(application.amount or config.amount or 0),
                    "rank_position": item.rank_position,
                    "is_allocated": True,
                    "backup_info": item.backup_allocations or [],
                }

                allocated_students.append(student_info)

                # Update summary
                summary["total_allocated"] += 1
                summary["total_amount"] += student_info["amount"]

                if college not in summary["by_college"]:
                    summary["by_college"][college] = {"allocated": 0, "total_amount": 0.0}

                summary["by_college"][college]["allocated"] += 1
                summary["by_college"][college]["total_amount"] += student_info["amount"]

        else:
            # No ranking, get all approved applications for this config
            stmt = (
                select(Application)
                .where(
                    and_(
                        Application.scholarship_configuration_id == config_id,
                        Application.status == "approved",
                    )
                )
                .order_by(Application.created_at)
            )
            result = await db.execute(stmt)
            applications = result.scalars().all()

            for application in applications:
                student_data = application.student_data or {}
                college = student_data.get("std_academyno", "Unknown")

                student_info = {
                    "application_id": application.id,
                    "student_name": student_data.get("std_cname", ""),
                    "student_id": student_data.get("std_id", ""),
                    "student_id_number": student_data.get("std_stdcode", ""),
                    "email": student_data.get("com_email", ""),
                    "college": college,
                    "department": student_data.get("std_depno", ""),
                    "grade": student_data.get("std_grade", ""),
                    "sub_type": application.sub_scholarship_type,
                    "amount": float(application.amount or config.amount or 0),
                    "rank_position": None,
                    "is_allocated": True,
                    "backup_info": [],
                }

                allocated_students.append(student_info)

                # Update summary
                summary["total_allocated"] += 1
                summary["total_amount"] += student_info["amount"]

                if college not in summary["by_college"]:
                    summary["by_college"][college] = {"allocated": 0, "total_amount": 0.0}

                summary["by_college"][college]["allocated"] += 1
                summary["by_college"][college]["total_amount"] += student_info["amount"]

        return ApiResponse(
            success=True,
            message="查詢成功",
            data={
                "has_matrix_distribution": has_matrix_distribution,
                "ranking_id": ranking_id,
                "allocated_students": allocated_students,
                "summary": summary,
            },
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to preview students for config {config_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="預覽學生名單失敗")


@router.get("/cycle-status")
async def get_roster_cycle_status(
    config_id: int = Query(..., description="獎學金配置ID"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊週期狀態
    Get roster cycle status for a scholarship configuration

    Returns:
        - schedule: 排程資訊
        - roster_cycle: 造冊週期 (monthly/semi_yearly/yearly)
        - periods: 期間列表 (已完成 + 等待造冊)
    """
    check_user_roles([UserRole.admin, UserRole.super_admin], current_user)

    try:
        from app.models.roster_schedule import RosterSchedule
        from app.models.scholarship import ScholarshipConfiguration

        # Get scholarship configuration
        stmt = select(ScholarshipConfiguration).where(ScholarshipConfiguration.id == config_id)
        result = await db.execute(stmt)
        config = result.scalar_one_or_none()

        if not config:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到獎學金配置")

        # Get schedule for this config
        stmt = select(RosterSchedule).where(RosterSchedule.scholarship_configuration_id == config_id)
        result = await db.execute(stmt)
        schedule = result.scalar_one_or_none()

        if not schedule:
            return ApiResponse(
                success=True,
                message="未找到排程",
                data={
                    "schedule": None,
                    "roster_cycle": None,
                    "periods": [],
                },
            )

        # Get existing rosters for this config
        stmt = (
            select(PaymentRoster)
            .where(PaymentRoster.scholarship_configuration_id == config_id)
            .order_by(PaymentRoster.period_label.desc())
        )
        result = await db.execute(stmt)
        existing_rosters = result.scalars().all()

        # Create a map of period_label -> roster
        roster_map = {roster.period_label: roster for roster in existing_rosters}

        # Generate period list based on roster_cycle
        periods = []
        academic_year = config.academic_year

        if schedule.roster_cycle.value == "monthly":
            # Determine if this is a yearly (academic year) scholarship
            is_yearly = config.semester is None or config.semester.value == "annual"

            # Generate 12 months
            # For yearly scholarships: September to August (9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8)
            # For semester scholarships: January to December (1, 2, 3, ..., 12)
            if is_yearly:
                month_sequence = [9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8]
            else:
                month_sequence = list(range(1, 13))

            for month in month_sequence:
                period_label = f"{academic_year}-{month:02d}"
                roster = roster_map.get(period_label)

                # Calculate period dates
                period_dates = get_roster_period_dates(
                    academic_year=academic_year,
                    semester=config.semester.value if config.semester else None,
                    roster_cycle="monthly",
                    period_label=period_label,
                )

                # Calculate western calendar year-month for display
                western_year = academic_year + 1911
                calendar_year = western_year if month >= 9 else western_year + 1
                western_date = f"{calendar_year}-{month:02d}"
                display_label = f"{period_label} ({calendar_year}年{month}月)"

                if roster:
                    periods.append(
                        {
                            "label": period_label,
                            "western_date": western_date,
                            "display_label": display_label,
                            "status": "completed",
                            "roster_id": roster.id,
                            "roster_code": roster.roster_code,
                            "completed_at": roster.completed_at.isoformat() if roster.completed_at else None,
                            "total_amount": float(roster.total_amount) if roster.total_amount else 0,
                            "qualified_count": roster.qualified_count,
                            "period_start_date": period_dates["start_date"].isoformat(),
                            "period_end_date": period_dates["end_date"].isoformat(),
                        }
                    )
                else:
                    periods.append(
                        {
                            "label": period_label,
                            "western_date": western_date,
                            "display_label": display_label,
                            "status": "waiting",
                            "next_schedule": schedule.next_run_at.isoformat() if schedule.next_run_at else None,
                            "estimated_count": 0,  # TODO: Calculate estimated count
                            "period_start_date": period_dates["start_date"].isoformat(),
                            "period_end_date": period_dates["end_date"].isoformat(),
                        }
                    )

        elif schedule.roster_cycle.value == "semi_yearly":
            # Generate 2 half-year periods
            for half in ["H1", "H2"]:
                period_label = f"{academic_year}-{half}"
                roster = roster_map.get(period_label)

                # Calculate period dates
                period_dates = get_roster_period_dates(
                    academic_year=academic_year,
                    semester=config.semester.value if config.semester else None,
                    roster_cycle="semi_yearly",
                    period_label=period_label,
                )

                if roster:
                    periods.append(
                        {
                            "label": period_label,
                            "status": "completed",
                            "roster_id": roster.id,
                            "roster_code": roster.roster_code,
                            "completed_at": roster.completed_at.isoformat() if roster.completed_at else None,
                            "total_amount": float(roster.total_amount) if roster.total_amount else 0,
                            "qualified_count": roster.qualified_count,
                            "period_start_date": period_dates["start_date"].isoformat(),
                            "period_end_date": period_dates["end_date"].isoformat(),
                        }
                    )
                else:
                    periods.append(
                        {
                            "label": period_label,
                            "status": "waiting",
                            "next_schedule": schedule.next_run_at.isoformat() if schedule.next_run_at else None,
                            "estimated_count": 0,
                            "period_start_date": period_dates["start_date"].isoformat(),
                            "period_end_date": period_dates["end_date"].isoformat(),
                        }
                    )

        elif schedule.roster_cycle.value == "yearly":
            # Generate 1 yearly period
            period_label = str(academic_year)
            roster = roster_map.get(period_label)

            # Calculate period dates
            period_dates = get_roster_period_dates(
                academic_year=academic_year,
                semester=config.semester.value if config.semester else None,
                roster_cycle="yearly",
                period_label=period_label,
            )

            if roster:
                periods.append(
                    {
                        "label": period_label,
                        "status": "completed",
                        "roster_id": roster.id,
                        "roster_code": roster.roster_code,
                        "completed_at": roster.completed_at.isoformat() if roster.completed_at else None,
                        "total_amount": float(roster.total_amount) if roster.total_amount else 0,
                        "qualified_count": roster.qualified_count,
                        "period_start_date": period_dates["start_date"].isoformat(),
                        "period_end_date": period_dates["end_date"].isoformat(),
                    }
                )
            else:
                periods.append(
                    {
                        "label": period_label,
                        "status": "waiting",
                        "next_schedule": schedule.next_run_at.isoformat() if schedule.next_run_at else None,
                        "estimated_count": 0,
                        "period_start_date": period_dates["start_date"].isoformat(),
                        "period_end_date": period_dates["end_date"].isoformat(),
                    }
                )

        return ApiResponse(
            success=True,
            message="查詢成功",
            data={
                "schedule": {
                    "id": schedule.id,
                    "schedule_name": schedule.schedule_name,
                    "roster_cycle": schedule.roster_cycle.value,
                    "cron_expression": schedule.cron_expression,
                    "status": schedule.status.value,
                    "next_run_at": schedule.next_run_at.isoformat() if schedule.next_run_at else None,
                    "last_run_at": schedule.last_run_at.isoformat() if schedule.last_run_at else None,
                },
                "roster_cycle": schedule.roster_cycle.value,
                "periods": periods,
            },
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get cycle status for config {config_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="查詢造冊週期狀態失敗")


@router.get("/{roster_id}")
async def get_payment_roster(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得特定造冊詳細資訊
    Get specific payment roster details
    """
    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)
        result = await db.execute(stmt)
        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        response_data = RosterResponse.from_orm(roster)
        return ApiResponse(
            success=True,
            message="查詢成功",
            data=response_data.model_dump() if hasattr(response_data, "model_dump") else response_data.dict(),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得造冊詳情失敗")


@router.get("/{roster_id}/items")
async def get_roster_items(
    roster_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=500),
    verification_status: Optional[StudentVerificationStatus] = Query(None),
    is_qualified: Optional[bool] = Query(None),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊明細項目
    Get roster items
    """
    try:
        # 檢查造冊是否存在
        roster_stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)
        roster_result = await db.execute(roster_stmt)
        roster = roster_result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        stmt = select(PaymentRosterItem).where(PaymentRosterItem.roster_id == roster_id)

        # 套用篩選條件
        if verification_status:
            stmt = stmt.where(PaymentRosterItem.verification_status == verification_status)
        if is_qualified is not None:
            stmt = stmt.where(PaymentRosterItem.is_qualified == is_qualified)

        # 分頁查詢
        stmt = stmt.order_by(PaymentRosterItem.created_at).offset(skip).limit(limit)
        result = await db.execute(stmt)
        items = result.scalars().all()

        items_data = [RosterItemResponse.from_orm(item) for item in items]
        return ApiResponse(
            success=True,
            message="查詢成功",
            data=[item.model_dump() if hasattr(item, "model_dump") else item.dict() for item in items_data],
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get roster items for {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得造冊明細失敗")


@router.post("/{roster_id}/lock")
async def lock_roster(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    鎖定造冊
    Lock roster
    """
    # 檢查權限：只有管理員可以鎖定造冊
    check_user_roles([UserRole.admin], current_user)

    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)
        result = await db.execute(stmt)
        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        if roster.status == RosterStatus.LOCKED:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="造冊已經被鎖定")

        roster.status = RosterStatus.LOCKED
        roster.locked_at = datetime.utcnow()
        roster.locked_by_user_id = current_user.id

        await db.commit()

        logger.info(f"Roster {roster.roster_code} locked by user {current_user.id}")

        return ApiResponse(
            success=True,
            message="造冊已鎖定",
            data={"roster_code": roster.roster_code},
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to lock roster {roster_id}: {e}")
        await db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="鎖定造冊失敗")


@router.post("/{roster_id}/unlock")
async def unlock_roster(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    解鎖造冊
    Unlock roster
    """
    # 檢查權限：只有管理員可以解鎖造冊
    check_user_roles([UserRole.admin], current_user)

    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        if roster.status != RosterStatus.LOCKED:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="造冊未被鎖定")

        roster.status = RosterStatus.COMPLETED
        roster.locked_at = None
        roster.locked_by_user_id = None

        await db.commit()

        logger.info(f"Roster {roster.roster_code} unlocked by user {current_user.id}")

        return ApiResponse(
            success=True,
            message="造冊已解鎖",
            data={"roster_code": roster.roster_code},
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to unlock roster {roster_id}: {e}")
        await db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="解鎖造冊失敗")


@router.get("/{roster_id}/preview")
def preview_roster_export(
    roster_id: int,
    template_name: str = Query("STD_UP_MIXLISTA", description="Excel範本名稱"),
    include_header: bool = Query(True, description="是否包含標題行"),
    max_preview_rows: int = Query(10, description="預覽模式最大行數"),
    include_excluded: bool = Query(False, description="是否包含排除項目"),
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    預覽造冊Excel匯出內容
    Preview roster Excel export content
    """
    try:
        roster = db.query(PaymentRoster).filter(PaymentRoster.id == roster_id).first()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        export_service = ExcelExportService()

        # 預覽模式：只產生資料預覽，不實際建立檔案
        preview_result = export_service.preview_roster_export(
            roster=roster,
            template_name=template_name,
            include_header=include_header,
            max_preview_rows=max_preview_rows or 10,
            include_excluded=include_excluded,
        )

        logger.info(f"Roster {roster.roster_code} preview generated by user {current_user.id}")

        return ApiResponse(
            success=True,
            message="預覽產生成功",
            data={
                "roster_code": roster.roster_code,
                "preview_data": preview_result["preview_data"],
                "total_rows": preview_result["total_rows"],
                "column_headers": preview_result["column_headers"],
                "validation_result": preview_result["validation_result"],
                "export_metadata": preview_result["metadata"],
            },
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to preview roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="預覽產生失敗")


@router.post("/{roster_id}/dry-run")
def dry_run_roster_generation(
    roster_id: int,
    request: RosterCreateRequest,
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    造冊產生預演 (不實際建立造冊)
    Dry run roster generation (without actually creating roster)
    """
    try:
        # 檢查權限
        check_user_roles([UserRole.admin, UserRole.super_admin], current_user)

        roster_service = RosterService(db)

        # 執行預演模式
        dry_run_result = roster_service.dry_run_generate_roster(
            scholarship_configuration_id=request.scholarship_configuration_id,
            period_label=request.period_label,
            roster_cycle=request.roster_cycle,
            academic_year=request.academic_year,
            student_verification_enabled=request.student_verification_enabled,
        )

        logger.info(
            f"Dry run completed for scholarship config {request.scholarship_configuration_id} "
            f"by user {current_user.id}"
        )

        return ApiResponse(
            success=True,
            message="預演完成",
            data={
                "dry_run_result": dry_run_result,
                "estimated_items": dry_run_result["estimated_items"],
                "estimated_total_amount": dry_run_result["estimated_total_amount"],
                "potential_issues": dry_run_result["potential_issues"],
                "validation_summary": dry_run_result["validation_summary"],
                "duplicate_check": dry_run_result["duplicate_check"],
            },
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to dry run roster generation: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="預演失敗")


@router.post("/{roster_id}/export")
def export_roster_to_excel(
    roster_id: int,
    request: RosterExportRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    匯出造冊至Excel (STD_UP_MIXLISTA格式)
    Export roster to Excel (STD_UP_MIXLISTA format)
    """
    try:
        roster = db.query(PaymentRoster).filter(PaymentRoster.id == roster_id).first()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        export_service = ExcelExportService()

        # 使用新的STD_UP_MIXLISTA格式匯出
        export_result = export_service.export_roster_to_excel(
            roster=roster,
            template_name=request.template_name or "STD_UP_MIXLISTA",
            include_header=request.include_header,
            include_statistics=request.include_statistics,
            include_excluded=request.include_excluded,
            async_mode=request.async_mode or False,
        )

        if request.async_mode:
            background_tasks.add_task(
                export_service.process_async_export,
                roster_id,
                export_result["task_id"],
                current_user.id,
                template_name=request.template_name,
                include_header=request.include_header,
                include_statistics=request.include_statistics,
                include_excluded=request.include_excluded,
            )

            logger.info(
                "Roster %s export queued in async mode by user %s (task %s)",
                roster.roster_code,
                current_user.id,
                export_result["task_id"],
            )

            return ApiResponse(
                success=True,
                message="Excel檔案匯出已開始 (非同步模式)",
                data={
                    "task_id": export_result["task_id"],
                    "status": export_result["status"],
                    "estimated_completion": export_result.get("estimated_completion"),
                },
            )

        logger.info(
            "Roster %s exported to %s by user %s",
            roster.roster_code,
            export_result["file_path"],
            current_user.id,
        )

        return ApiResponse(
            success=True,
            message="Excel檔案匯出成功",
            data={
                "file_path": export_result["file_path"],
                "file_size": export_result["file_size"],
                "validation_result": export_result["validation_result"],
                "download_url": f"/api/v1/payment-rosters/{roster_id}/download",
                "minio_object_name": export_result.get("minio_object_name"),
            },
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to export roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Excel匯出失敗")


@router.get("/{roster_id}/download")
async def download_roster_excel(
    roster_id: int,
    use_minio: bool = Query(True, description="是否使用MinIO下載"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    下載造冊Excel檔案 (支援MinIO和本地檔案)
    Download roster Excel file (supports MinIO and local files)
    """
    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        from app.services.audit_service import audit_service
        from app.services.minio_service import minio_service

        if use_minio and hasattr(roster, "minio_object_name") and roster.minio_object_name:
            # SECURITY: Validate MinIO object name (CLAUDE.md requirement)
            try:
                validate_object_name_minio(roster.minio_object_name)
            except HTTPException:
                logger.error(f"Invalid minio_object_name from database: {roster.minio_object_name}")
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="MinIO object name驗證失敗")

            # 使用MinIO下載
            try:
                file_content, metadata = minio_service.download_roster_file(roster.minio_object_name)

                # 記錄下載日誌
                audit_service.log_file_download(
                    roster_id=roster_id,
                    filename=roster.minio_object_name,
                    user_id=current_user.id,
                    user_name=current_user.username,
                    download_method="minio",
                    db=db,
                )

                logger.info(f"Roster {roster.roster_code} downloaded from MinIO by user {current_user.id}")

                # 產生預簽名URL供前端下載
                presigned_url = minio_service.get_presigned_url(
                    object_name=roster.minio_object_name, expires=timedelta(hours=1)
                )

                return ApiResponse(
                    success=True,
                    message="檔案下載準備完成",
                    data={
                        "download_url": presigned_url,
                        "filename": metadata.get("original-filename", f"{roster.roster_code}.xlsx"),
                        "file_size": len(file_content),
                        "content_type": metadata.get(
                            "Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                        ),
                        "download_method": "minio",
                        "expires_at": (datetime.now() + timedelta(hours=1)).isoformat(),
                    },
                )

            except Exception as e:
                logger.warning(f"MinIO download failed, falling back to local file: {e}")
                use_minio = False

        if not use_minio:
            # 本地檔案下載或MinIO失敗後的回退方案
            if hasattr(roster, "excel_file_path") and roster.excel_file_path and os.path.exists(roster.excel_file_path):
                # 記錄下載日誌
                audit_service.log_file_download(
                    roster_id=roster_id,
                    filename=os.path.basename(roster.excel_file_path),
                    user_id=current_user.id,
                    user_name=current_user.username,
                    download_method="local",
                    db=db,
                )

                logger.info(f"Roster {roster.roster_code} downloaded locally by user {current_user.id}")

                return FileResponse(
                    path=roster.excel_file_path,
                    filename=f"{roster.roster_code}.xlsx",
                    media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                )
            else:
                # 沒有可用的檔案，重新產生
                export_service = ExcelExportService()
                export_result = export_service.export_roster_to_excel(
                    roster=roster,
                    template_name="STD_UP_MIXLISTA",
                    include_header=True,
                    include_statistics=True,
                    include_excluded=False,
                )

                logger.info(f"Roster {roster.roster_code} re-generated and downloaded by user {current_user.id}")

                return FileResponse(
                    path=export_result["file_path"],
                    filename=f"{roster.roster_code}.xlsx",
                    media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to download roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="下載造冊失敗")


@router.get("/{roster_id}/statistics")
async def get_roster_statistics(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊統計資訊
    Get roster statistics
    """
    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        # 統計各驗證狀態的人數
        verification_stats = {}
        for status_val in StudentVerificationStatus:
            item_count = (
                await db.execute(
                    select(count())
                    .select_from(PaymentRosterItem)
                    .where(
                        PaymentRosterItem.roster_id == roster_id, PaymentRosterItem.verification_status == status_val
                    )
                )
            ).scalar()
            verification_stats[status_val.value] = item_count

        # 統計合格/不合格人數
        qualified_stmt = (
            select(count())
            .select_from(PaymentRosterItem)
            .where(PaymentRosterItem.roster_id == roster_id, PaymentRosterItem.is_qualified.is_(True))
        )
        qualified_result = await db.execute(qualified_stmt)
        qualified_count = qualified_result.scalar() or 0

        disqualified_stmt = (
            select(count())
            .select_from(PaymentRosterItem)
            .where(PaymentRosterItem.roster_id == roster_id, PaymentRosterItem.is_qualified.is_(False))
        )
        disqualified_result = await db.execute(disqualified_stmt)
        disqualified_count = disqualified_result.scalar() or 0

        response_data = RosterStatisticsResponse(
            roster_id=roster_id,
            total_items=qualified_count + disqualified_count,
            qualified_count=qualified_count,
            disqualified_count=disqualified_count,
            total_amount=roster.total_amount,
            verification_status_counts=verification_stats,
            created_at=roster.created_at,
            status=roster.status,
        )
        return ApiResponse(
            success=True,
            message="查詢成功",
            data=response_data.model_dump() if hasattr(response_data, "model_dump") else response_data.dict(),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get roster statistics for {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得造冊統計失敗")


@router.delete("/{roster_id}")
async def delete_roster(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    刪除造冊（僅限未鎖定的造冊）
    Delete roster (only unlocked rosters)
    """
    # 檢查權限：只有管理員可以刪除造冊
    check_user_roles([UserRole.admin], current_user)

    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        if roster.status == RosterStatus.LOCKED:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="無法刪除已鎖定的造冊")

        # 刪除造冊項目和稽核記錄（透過cascade）
        await db.delete(roster)
        await db.commit()

        logger.info(f"Roster {roster.roster_code} deleted by user {current_user.id}")

        return ApiResponse(
            success=True,
            message="造冊已刪除",
            data=None,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete roster {roster_id}: {e}")
        await db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="刪除造冊失敗")


@router.get("/{roster_id}/audit-logs")
async def get_roster_audit_logs(
    roster_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=500),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊稽核日誌
    Get roster audit logs
    """
    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        from app.models.roster_audit import RosterAuditLog

        stmt = (
            select(RosterAuditLog)
            .where(RosterAuditLog.roster_id == roster_id)
            .order_by(RosterAuditLog.created_at.desc())
        )

        count_result = await db.execute(select(count()).select_from(stmt.subquery()))
        total = count_result.scalar()
        stmt = stmt.offset(skip).limit(limit)
        result = await db.execute(stmt)
        logs = result.scalars().all()

        return ApiResponse(
            success=True,
            message="查詢成功",
            data={
                "items": [
                    {
                        "id": log.id,
                        "action": log.action.value,
                        "level": log.level.value,
                        "title": log.title,
                        "description": log.description,
                        "created_by_user_id": log.created_by_user_id,
                        "created_at": log.created_at,
                        "audit_metadata": log.audit_metadata,
                    }
                    for log in logs
                ],
                "total": total,
                "skip": skip,
                "limit": limit,
            },
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get audit logs for roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="查詢稽核日誌失敗")
