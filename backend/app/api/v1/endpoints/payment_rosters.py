"""
Payment roster API endpoints
造冊相關API端點
"""

import logging
import os
from datetime import datetime, timedelta
from typing import List, Optional

from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, Query, status
from fastapi.responses import FileResponse
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Session
from sqlalchemy.sql.functions import count

from app.core.deps import get_current_user
from app.core.security import check_user_roles
from app.db.deps import get_db, get_sync_db
from app.models.payment_roster import (
    PaymentRoster,
    PaymentRosterItem,
    RosterStatus,
    RosterTriggerType,
    StudentVerificationStatus,
)
from app.models.user import User, UserRole
from app.schemas.roster import (
    RosterCreateRequest,
    RosterExportRequest,
    RosterItemResponse,
    RosterListResponse,
    RosterResponse,
    RosterStatisticsResponse,
)
from app.services.excel_export_service import ExcelExportService
from app.services.roster_service import RosterService

logger = logging.getLogger(__name__)

router = APIRouter()


@router.post("/generate", response_model=RosterResponse)
def generate_payment_roster(
    request: RosterCreateRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    產生造冊
    Generate payment roster
    """
    # 檢查權限：只有管理員和處理人員可以產生造冊
    check_user_roles([UserRole.admin, UserRole.super_admin], current_user)

    try:
        roster_service = RosterService(db)

        # 產生造冊
        roster = roster_service.generate_roster(
            scholarship_configuration_id=request.scholarship_configuration_id,
            period_label=request.period_label,
            roster_cycle=request.roster_cycle,
            academic_year=request.academic_year,
            created_by_user_id=current_user.id,
            trigger_type=RosterTriggerType.MANUAL,
            student_verification_enabled=request.student_verification_enabled,
        )

        logger.info(f"Roster {roster.roster_code} generated by user {current_user.id}")

        return RosterResponse.from_orm(roster)

    except ValueError as e:
        logger.warning(f"Roster generation validation error: {e}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        logger.error(f"Error generating roster: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to generate roster")


@router.get("", response_model=RosterListResponse)
async def list_payment_rosters(
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=100),
    scholarship_configuration_id: Optional[int] = Query(None),
    status_filter: Optional[RosterStatus] = Query(None),
    period_label: Optional[str] = Query(None),
    academic_year: Optional[int] = Query(None),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊清單
    Get payment roster list
    """
    try:
        # Build query
        stmt = select(PaymentRoster)

        # 套用篩選條件
        if scholarship_configuration_id:
            stmt = stmt.where(PaymentRoster.scholarship_configuration_id == scholarship_configuration_id)
        if status_filter:
            stmt = stmt.where(PaymentRoster.status == status_filter)
        if period_label:
            stmt = stmt.where(PaymentRoster.period_label == period_label)
        if academic_year:
            stmt = stmt.where(PaymentRoster.academic_year == academic_year)

        # 計算總數
        count_stmt = select(count()).select_from(stmt.subquery())
        total_result = await db.execute(count_stmt)
        total = total_result.scalar()

        # 套用分頁
        stmt = stmt.order_by(PaymentRoster.created_at.desc()).offset(skip).limit(limit)
        result = await db.execute(stmt)
        rosters = result.scalars().all()

        return RosterListResponse(
            items=[RosterResponse.from_orm(roster) for roster in rosters], total=total or 0, skip=skip, limit=limit
        )

    except Exception as e:
        logger.error(f"Failed to list rosters: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得造冊清單失敗")


@router.get("/{roster_id}", response_model=RosterResponse)
async def get_payment_roster(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得特定造冊詳細資訊
    Get specific payment roster details
    """
    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)
        result = await db.execute(stmt)
        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        return RosterResponse.from_orm(roster)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得造冊詳情失敗")


@router.get("/{roster_id}/items", response_model=List[RosterItemResponse])
async def get_roster_items(
    roster_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=500),
    verification_status: Optional[StudentVerificationStatus] = Query(None),
    is_qualified: Optional[bool] = Query(None),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊明細項目
    Get roster items
    """
    try:
        # 檢查造冊是否存在
        roster_stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)
        roster_result = await db.execute(roster_stmt)
        roster = roster_result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        stmt = select(PaymentRosterItem).where(PaymentRosterItem.roster_id == roster_id)

        # 套用篩選條件
        if verification_status:
            stmt = stmt.where(PaymentRosterItem.verification_status == verification_status)
        if is_qualified is not None:
            stmt = stmt.where(PaymentRosterItem.is_qualified == is_qualified)

        # 分頁查詢
        stmt = stmt.order_by(PaymentRosterItem.created_at).offset(skip).limit(limit)
        result = await db.execute(stmt)
        items = result.scalars().all()

        return [RosterItemResponse.from_orm(item) for item in items]

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get roster items for {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得造冊明細失敗")


@router.post("/{roster_id}/lock")
async def lock_roster(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    鎖定造冊
    Lock roster
    """
    # 檢查權限：只有管理員可以鎖定造冊
    check_user_roles([UserRole.admin], current_user)

    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)
        result = await db.execute(stmt)
        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        if roster.status == RosterStatus.LOCKED:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="造冊已經被鎖定")

        roster.status = RosterStatus.LOCKED
        roster.locked_at = datetime.utcnow()
        roster.locked_by_user_id = current_user.id

        await db.commit()

        logger.info(f"Roster {roster.roster_code} locked by user {current_user.id}")

        return {"message": "造冊已鎖定", "roster_code": roster.roster_code}

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to lock roster {roster_id}: {e}")
        await db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="鎖定造冊失敗")


@router.post("/{roster_id}/unlock")
async def unlock_roster(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    解鎖造冊
    Unlock roster
    """
    # 檢查權限：只有管理員可以解鎖造冊
    check_user_roles([UserRole.admin], current_user)

    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        if roster.status != RosterStatus.LOCKED:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="造冊未被鎖定")

        roster.status = RosterStatus.COMPLETED
        roster.locked_at = None
        roster.locked_by_user_id = None

        await db.commit()

        logger.info(f"Roster {roster.roster_code} unlocked by user {current_user.id}")

        return {"message": "造冊已解鎖", "roster_code": roster.roster_code}

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to unlock roster {roster_id}: {e}")
        await db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="解鎖造冊失敗")


@router.post("/{roster_id}/preview")
def preview_roster_export(
    roster_id: int,
    request: RosterExportRequest,
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    預覽造冊Excel匯出內容
    Preview roster Excel export content
    """
    try:
        roster = db.query(PaymentRoster).filter(PaymentRoster.id == roster_id).first()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        export_service = ExcelExportService()

        # 預覽模式：只產生資料預覽，不實際建立檔案
        preview_result = export_service.preview_roster_export(
            roster=roster,
            template_name=request.template_name,
            include_header=request.include_header,
            max_preview_rows=request.max_preview_rows or 10,
        )

        logger.info(f"Roster {roster.roster_code} preview generated by user {current_user.id}")

        return {
            "message": "預覽產生成功",
            "roster_code": roster.roster_code,
            "preview_data": preview_result["preview_data"],
            "total_rows": preview_result["total_rows"],
            "column_headers": preview_result["column_headers"],
            "validation_result": preview_result["validation_result"],
            "export_metadata": preview_result["metadata"],
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to preview roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="預覽產生失敗")


@router.post("/{roster_id}/dry-run")
def dry_run_roster_generation(
    roster_id: int,
    request: RosterCreateRequest,
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    造冊產生預演 (不實際建立造冊)
    Dry run roster generation (without actually creating roster)
    """
    try:
        # 檢查權限
        check_user_roles([UserRole.admin, UserRole.super_admin], current_user)

        roster_service = RosterService(db)

        # 執行預演模式
        dry_run_result = roster_service.dry_run_generate_roster(
            scholarship_configuration_id=request.scholarship_configuration_id,
            period_label=request.period_label,
            roster_cycle=request.roster_cycle,
            academic_year=request.academic_year,
            student_verification_enabled=request.student_verification_enabled,
        )

        logger.info(
            f"Dry run completed for scholarship config {request.scholarship_configuration_id} "
            f"by user {current_user.id}"
        )

        return {
            "message": "預演完成",
            "dry_run_result": dry_run_result,
            "estimated_items": dry_run_result["estimated_items"],
            "estimated_total_amount": dry_run_result["estimated_total_amount"],
            "potential_issues": dry_run_result["potential_issues"],
            "validation_summary": dry_run_result["validation_summary"],
            "duplicate_check": dry_run_result["duplicate_check"],
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to dry run roster generation: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="預演失敗")


@router.post("/{roster_id}/export")
def export_roster_to_excel(
    roster_id: int,
    request: RosterExportRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_sync_db),
    current_user: User = Depends(get_current_user),
):
    """
    匯出造冊至Excel (STD_UP_MIXLISTA格式)
    Export roster to Excel (STD_UP_MIXLISTA format)
    """
    try:
        roster = db.query(PaymentRoster).filter(PaymentRoster.id == roster_id).first()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        export_service = ExcelExportService()

        # 使用新的STD_UP_MIXLISTA格式匯出
        export_result = export_service.export_roster_to_excel(
            roster=roster,
            template_name=request.template_name or "STD_UP_MIXLISTA",
            include_header=request.include_header,
            include_statistics=request.include_statistics,
            async_mode=request.async_mode or False,
        )

        logger.info(f"Roster {roster.roster_code} exported to {export_result['file_path']} by user {current_user.id}")

        # 如果是非同步模式，將任務加入背景處理
        if request.async_mode:
            background_tasks.add_task(
                export_service.process_async_export, roster_id, export_result["task_id"], current_user.id
            )

            return {
                "message": "Excel檔案匯出已開始 (非同步模式)",
                "task_id": export_result["task_id"],
                "status": "processing",
                "estimated_completion": export_result.get("estimated_completion"),
            }
        else:
            return {
                "message": "Excel檔案匯出成功",
                "file_path": export_result["file_path"],
                "file_size": export_result["file_size"],
                "validation_result": export_result["validation_result"],
                "download_url": f"/api/v1/payment-rosters/{roster_id}/download",
                "minio_object_name": export_result.get("minio_object_name"),
            }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to export roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Excel匯出失敗")


@router.get("/{roster_id}/download")
async def download_roster_excel(
    roster_id: int,
    use_minio: bool = Query(True, description="是否使用MinIO下載"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    下載造冊Excel檔案 (支援MinIO和本地檔案)
    Download roster Excel file (supports MinIO and local files)
    """
    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        from app.services.audit_service import audit_service
        from app.services.minio_service import minio_service

        if use_minio and hasattr(roster, "minio_object_name") and roster.minio_object_name:
            # 使用MinIO下載
            try:
                file_content, metadata = minio_service.download_roster_file(roster.minio_object_name)

                # 記錄下載日誌
                audit_service.log_file_download(
                    roster_id=roster_id,
                    filename=roster.minio_object_name,
                    user_id=current_user.id,
                    user_name=current_user.username,
                    download_method="minio",
                    db=db,
                )

                logger.info(f"Roster {roster.roster_code} downloaded from MinIO by user {current_user.id}")

                # 產生預簽名URL供前端下載
                presigned_url = minio_service.get_presigned_url(
                    object_name=roster.minio_object_name, expires=timedelta(hours=1)
                )

                return {
                    "message": "檔案下載準備完成",
                    "download_url": presigned_url,
                    "filename": metadata.get("original-filename", f"{roster.roster_code}.xlsx"),
                    "file_size": len(file_content),
                    "content_type": metadata.get(
                        "Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    ),
                    "download_method": "minio",
                    "expires_at": (datetime.now() + timedelta(hours=1)).isoformat(),
                }

            except Exception as e:
                logger.warning(f"MinIO download failed, falling back to local file: {e}")
                use_minio = False

        if not use_minio:
            # 本地檔案下載或MinIO失敗後的回退方案
            if hasattr(roster, "excel_file_path") and roster.excel_file_path and os.path.exists(roster.excel_file_path):
                # 記錄下載日誌
                audit_service.log_file_download(
                    roster_id=roster_id,
                    filename=os.path.basename(roster.excel_file_path),
                    user_id=current_user.id,
                    user_name=current_user.username,
                    download_method="local",
                    db=db,
                )

                logger.info(f"Roster {roster.roster_code} downloaded locally by user {current_user.id}")

                return FileResponse(
                    path=roster.excel_file_path,
                    filename=f"{roster.roster_code}.xlsx",
                    media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                )
            else:
                # 沒有可用的檔案，重新產生
                export_service = ExcelExportService()
                export_result = export_service.export_roster_to_excel(
                    roster=roster,
                    template_name="STD_UP_MIXLISTA",
                    include_header=True,
                    include_statistics=True,
                )

                logger.info(f"Roster {roster.roster_code} re-generated and downloaded by user {current_user.id}")

                return FileResponse(
                    path=export_result["file_path"],
                    filename=f"{roster.roster_code}.xlsx",
                    media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to download roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="下載造冊失敗")


@router.get("/{roster_id}/statistics", response_model=RosterStatisticsResponse)
async def get_roster_statistics(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊統計資訊
    Get roster statistics
    """
    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        # 統計各驗證狀態的人數
        verification_stats = {}
        for status_val in StudentVerificationStatus:
            item_count = (
                await db.execute(
                    select(count())
                    .select_from(PaymentRosterItem)
                    .where(
                        PaymentRosterItem.roster_id == roster_id, PaymentRosterItem.verification_status == status_val
                    )
                )
            ).scalar()
            verification_stats[status_val.value] = item_count

        # 統計合格/不合格人數
        qualified_stmt = (
            select(count())
            .select_from(PaymentRosterItem)
            .where(PaymentRosterItem.roster_id == roster_id, PaymentRosterItem.is_qualified.is_(True))
        )
        qualified_result = await db.execute(qualified_stmt)
        qualified_count = qualified_result.scalar() or 0

        disqualified_stmt = (
            select(count())
            .select_from(PaymentRosterItem)
            .where(PaymentRosterItem.roster_id == roster_id, PaymentRosterItem.is_qualified.is_(False))
        )
        disqualified_result = await db.execute(disqualified_stmt)
        disqualified_count = disqualified_result.scalar() or 0

        return RosterStatisticsResponse(
            roster_id=roster_id,
            total_items=qualified_count + disqualified_count,
            qualified_count=qualified_count,
            disqualified_count=disqualified_count,
            total_amount=roster.total_amount,
            verification_status_counts=verification_stats,
            created_at=roster.created_at,
            status=roster.status,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get roster statistics for {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得造冊統計失敗")


@router.delete("/{roster_id}")
async def delete_roster(
    roster_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    刪除造冊（僅限未鎖定的造冊）
    Delete roster (only unlocked rosters)
    """
    # 檢查權限：只有管理員可以刪除造冊
    check_user_roles([UserRole.admin], current_user)

    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        if roster.status == RosterStatus.LOCKED:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="無法刪除已鎖定的造冊")

        # 刪除造冊項目和稽核記錄（透過cascade）
        db.delete(roster)
        await db.commit()

        logger.info(f"Roster {roster.roster_code} deleted by user {current_user.id}")

        return {"message": "造冊已刪除"}

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete roster {roster_id}: {e}")
        await db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="刪除造冊失敗")


@router.get("/{roster_id}/audit-logs")
async def get_roster_audit_logs(
    roster_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=500),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    取得造冊稽核日誌
    Get roster audit logs
    """
    try:
        stmt = select(PaymentRoster).where(PaymentRoster.id == roster_id)

        result = await db.execute(stmt)

        roster = result.scalar_one_or_none()

        if not roster:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定的造冊")

        from app.models.roster_audit import RosterAuditLog

        stmt = (
            select(RosterAuditLog)
            .where(RosterAuditLog.roster_id == roster_id)
            .order_by(RosterAuditLog.created_at.desc())
        )

        count_result = await db.execute(select(count()).select_from(stmt.subquery()))
        total = count_result.scalar()
        stmt = stmt.offset(skip).limit(limit)
        result = await db.execute(stmt)
        logs = result.scalars().all()

        return {
            "items": [
                {
                    "id": log.id,
                    "action": log.action.value,
                    "level": log.level.value,
                    "title": log.title,
                    "description": log.description,
                    "created_by_user_id": log.created_by_user_id,
                    "created_at": log.created_at,
                    "audit_metadata": log.audit_metadata,
                }
                for log in logs
            ],
            "total": total,
            "skip": skip,
            "limit": limit,
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get audit logs for roster {roster_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="取得稽核日誌失敗")
